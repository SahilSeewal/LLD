Design Patterns

1. Factory method/abstract pattern(parent abstract class containing one abstract createProduct() method. There are child classes(actual factories) which contains their implementations of createProduct() method to create concrete Product)- create multiple factories that create actual objects. 

2. State pattern(similar to state machine with single controller class responsible for invoking state object methods and changing states. Generally states invoke controller class methods and vice-versa)- single class(used as a controller as it contains the code to trigger the methods of states and contains reference of other states). Other states invoke the aforementioned class to swtich to diff state or to trigger another method of diff state. 

3. Visitor pattern(if want to implement some changes in all/few child classes of a parent class) - If there are classes of same parent(base class) and a change need to be made in all of them then we create a class say visitor containing all the methods implementing new details. We then create a new method say apply(visitor) in all the child classes of base class which will call visitor class methods. 

4. Observer pattern (publisher-subscriber approach) - there is a publisher and a subscriber class. Publisher contains register(subscriber) method to register specific subscriber. subscribers contains notify() method which publisher class calls for the registered subscriber. 

5. Strategy Pattern (segregation of classes) - Interface with multiple classes implementing it. 

6. Template pattern (Used to prevent re-write of same method invoke code in child classes) - A class containing a method say call() invoking other abstract methods of the same class. Child class of aforementioned class triggers call() method of parent class which in turn invokes it's abstract methods implementations in child class. 

7. Memento Pattern (used to store snapshots of object) - TextEditor class(contain set methods, createsnapshot method not get ones) contains all the properties as private and if want to keep it's snapshot to undo the property values at a later date. The aforementioned class creates snapshot by calling snapshot(texteditor, properties) constructor of snapshot class. Snapshot class contains method undo() which undo the texteditor object properties by calling texteditor.setproperties() method. There is a CareTaker class that takes the input from client to create snapshot which in turn call texteditor.createsnapshot() and store the result in list. Caretaker class also invoke the snapshot. undo() method that assigns the stored values of properties in snapshot object to texteditor object. 

8. Prototype pattern(used to make copy of object) - Each class constructor (MyClass(MyClass obj) ) must contain a parameter of itself. This constructor is called by a method clone() within this class. This method invokes the above constructor in this way: new MyClass(this). This pattern is used because here there is no need to provide properties while cloning object, this is possible because the same class constructor is taking reference of complete object. 

9. Mediator Pattern (if there are multiple classes wants to communicate with each other then to avoid direct links between the classes we use Mediator class with uses a common method say callMe(Component1, event) here calling party share it's reference along with the event it wants to share with component and the Mediator class contains appropriate conditions to forward the request to component2. This means that if component 1 shares event e1 then the mediator will always forward it to component 2(hard coded)) -  Say aeroplane1, aeroplane2 want to connect with each other then to avoid such direct relationship we use a mediator say airController class which uses a common methods say callAeroplane(aeroplane, message) and say aeroplane 1 uses it airController.callAeroplane(this, “how are you my friend”. Then mediator (airController) contains conditions for taking appropriate action corresponds to sender component and event. 

10. Command Pattern (Let say we have a class of Button it can be of 3 types submit button, ok button and search button to avoid such creation of classes based on minor minor diff in functionality command pattern is used) - Say we have a class Button class (client) and it can be used to invoke search functionality, submit functionality and ok functionality of Application class (service). Now to avoid creation of multiple clients classes (button 1, button2 etc) based on functionality of service they invoke. We use an intermediatory class say Command, whose constructor is like Command(Application). Now we can create 3 command classes say okCommand, submitCommand and searchCommand with method execute() invoking Application.ok(), Application.submit(), Application.search() respectively. Client class Button set command using Button.setCommand(Command[okCommand, searchCommand, submitCommand]) method. To trigger submit, ok and search Button(client) has methods triggerOk() {command[0].execute()}, triggerSearch() {command[1].execute()} and triggerSubmit() {command[2].execute()}

11. Adapter Pattern - (Used when we have a ClassA and wants to imitate as ClassB then we need some Adapter class that returns object of ClassB but works/access ClassA properties.) - Say there is a Duck interface containing methods say quack() and Turkey interface containing method say gobble(). Now we have a duck class say SimpleDuck and a turkey class say SimpleTurkey. If SimpleTurkey wants to imitate as Duck then we need create a DuckApapter class implementing Duck interface and a constructor DuckAdapter(Turkey) also method quack() {Turkey.gobble()}. Now a SimpleTurkey can be provided to DuckAdapter(SimpleTurkey) and DuckAdapter.quack() is invoked. 

12. Bridge Pattern - (When we have a classes of a particular type (say classes Circle and Rectangle belonging to class Shape) and need to be relate to classes of another type say(Red, Orange classes belonging to class Color) now we will implement bridge pattern connect these two classes i.e., circle can be of red or orangle color likewise for other. This prevents creation of different permutation of classes like redCircle, orangeCircle etc) - We create class of first type as general as possible say (Remote class) and create classes of other type as specific as possible say (Device interface implemented by TV, Radio class). Remote class constructor contains device name Remote(Device) and the other methods say on(){device.switchOn()}, off() {device.switchOff()}. This way we can do interaction between both classes without creation of permutation of classes of both types. 

13. Composite pattern: (It is used in situations where tree structure pattern is formed eg: say there is Box containing concrete Products and other Boxes. These Boxes may contain either concrete Products Or Boxes and so on. Now to form such a hierarchical structure composite pattern is used) - Let say we have have MenuComponent interface impllemented by Menu and MenuItem classes. Menu class contain List<MenuComponent> and getName() method this method iterate over list of menuComponents and call getName method. List<MenuComponent> may contain menuItem or menu objects. In MenuItem class only contain getName() method which will print the item name. 

14. Decorator Pattern- (If we have a Class say Message and we want to send the message to diff combination of notifier classes say SMS, WhatsApp, Slack etc. Note here more than combination of 2 classes can be possible. There avoid creation classes like MessageWhasAppSMS, MessageSMS etc decorator pattern is used) - Say we have a interface Beverage implemented by concrete coffee class say Expresso and an abstract class CoffeeDecorator. Expresso is a concrete coffee class has property price and getPrice() method is like getPrice(){return price;}. CoffeeDecorator class should contain a property of type Beverage, price and a constructor like CoffeeDecorator (Beverage). Say there are 2 decorator classes Mocha and Soy extending CoffeeDecorator class. Moreover these decorator classes contains getPrice() method in them is like getPrice(){return Beverage.getPrice() + price;}. Now if we want to make Mocha + Soy + Expresso we do following:
Beverage coffee = new Expresso () ;
coffee = new Soy(coffee) ;
coffee = new Mocha(coffee) ;
coffee. getPrice () ; //Mocha->Soy->Expresso

15. FlyWeight Pattern - (In a game containing Tree Class having properties say color, name, xCoordinate, yCoordinate. Here most of the trees have same color and name so instead of keeping them in all the Tree class objects and bulking it we can keep it in a seperate class also called FlyWeight class having property as name and color. Flyweight class object reference is provided to Tree class object whensover required hence preventing bulky objects and overall bulky system.) - TreeType class (fly weight class) containing most repeating properties of object say color and name. There is flyWeightFactory class which has method to create TreeType object say createTreeType(color, name) which verifies if TreeType object already exist then it return it's reference else create new one and store it for future. Let say we want to create an object of Tree class it should have property as TreeType and xCoordinate, yCoordinate. If we invoke createTree() method in Forest class(client) then creates Tree object using new Tree(flyWeightFactory.createTreeType(color, name), xCoordinate, yCoordinate). In Forest, Tree and TreeType class draw() method is overloaded because Tree properties of TreeType, xCoordinate, yCoordinate are private likewise true for TreeType properties color and name. Call of draw() method will be like Forest->Tree->TreeType.

16. Iterator Pattern - (Provides common interface for iteration) - Create a class say Channel with properties say name, age. Another class say ChannelCollection with property List<Channel> and  a nested private class ChannelIterator. Also contains methods say addToList(Channel), removeFromList(Channel), iterator() method returning ChannelIterator(List<Channel>). ChannelIterator class contains hasNext(), next() method which are used to access iterator. 
c = new ChannelCollection();
c.addToList(new Channel(“abc”, 300000)) 
i = c.iterator () 
i.next() ; i.hasNext() 

18. Proxy Pattern - (When we have a client class and service class but we want that before any request reach to service class there should be some intermediate class present to perform some required operations.) - There is Application class (client) and a ThirdPartyApp interface there is a class YouTube (service) and Cache class (intermediate) implementing it. Now Application class will call method of Cache class say cache. playVedio() which in turn invoke YouTube class method youtube.playVedio(). 

19. Builder pattern - (Used when we have a class containing lots of properties, it prevents creation of constructor with lot of properties parameters) - We create a class say Computer with properties hdd, graphic and constructor say Computer(ComputerBuilder). It also contains a nested static class ComputerBuilder this also contains properties as hdd and graphic. This nested class also contains methods like setGraphic(graphic), setHdd(hdd), they will return ComputerBuilder reference i.e., this. Also It contains a build() method which will call Computer(this) constructor and returns Computer class object. 

c = new Computer().ComputerBuilder().setHdd(“Toshiba”).setGraphic(“high”).build();

Other important patterns are:
20. Singleton pattern
21. Fascade pattern
22. Chain of responsibility pattern

